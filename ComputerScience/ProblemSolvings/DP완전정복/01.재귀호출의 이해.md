# Ch01. 재귀호출의 이해

## 1. 재귀 접근 방법이란?

재귀 사용할 경우

1. 항상 종료 조건 terminating condition 있어야
   - 어떤 경우에도 생략하면 안됨, 무한 호출 방지
2. 재귀 함수는 전체 작업의 일부만 수행하고 나머지는 재귀 호출에 위임

> 같은 문제를 비슷한 노력으로 해결할 수 있다면 재귀 호출 사용하지 않는 경우로 구현하는 것이 바람직
>
> 실행도 빠르고 필요한 메모리 양도 작기 때문

### 선행 재귀와 후행 재귀

- 선행 재귀: 함수가 작업을 수행하기 전 재귀 호출하는 경우; 이진 트리 후위 순회
- 후행 재귀: 함수가 작업 수행하고 마지막에 재귀 호출하는 경우; 이진 트리 전위 순회

이진트리 중위 순회하는 경우

- 이진 트리에서 NULL 포인터 수는 유효한 포인터 수 보다 항상 많기 때문에 조건문으로 함수 호출 횟수 줄여서 최적화

```c
void inOrder(node* ptr) {
  if (ptr == NULL) return;
  if (ptr->left != NULL) inOrder(ptr->left);
  printf("%c\n", ptr->data);
  if (ptr->right != NULL) inOrder(ptr->right);
}
```

---

## 2. 재귀 호출과 메모리

### 프로세스 주소 공간

- 프로세스process; 실행 파일 실행
- 프로세스가 생성되면 프로그램은 메모리(RAM)에 올라감, 이때 프로세스가 차지한 메모리 영역이 프로세스 주소 공간 **proess address space**
- OS가 프로세스에 할당
- 프로세스 주소 공간 영역의 구성
  - 코드 영역code segment; 텍스트 영역text segment
  - 데이터data segment
  - 스택stack segment
  - 힙heap segment

**코드 영역**

- 컴파일된 기계어 코드 저장; 실행 가능한 명령어 형태
- 읽기 전용, 프로그램 실행되는 동안 변경 불가
- 동일 프로그램 여러 개가 실행되더라도, 메모리에는 한 벌만 저장 가능하도록 여러 프로세스가 공유할 수 있음
- 크기는 프로그램이 메모리에 올라갈 때 정해짐

**데이터 영역**

- 모든 로드 타임 변수load-time variable(전역 변수global, 정적 변수static) 할당
  - 프로그램 로딩, main 함수 호출 전 메모리 할당
  - 로드 타임 변수 초기화; 초깃값 주어지지 않으면 해당 자료형의 0에 해당하는 값으로 초기화
    - ex. int -> 0, \*ptr -> NULL
- 내부적으로 초기화 변수 영역 - 초기화되지 않은 변수 영역으로 나뉨
  - 초기화되지 않은 데이터를 연속된 데이터 영역에 모아두면, 단 하나의 명령으로 한꺼번에 이 영역 변수들을 각 자료형의 0값으로 만들 수 있기 때문
- 프로그램이 메모리에 올라갈 때 할당

**스택 영역**

- 모든 활성 함수의 활성 레코드activation record(stack frame) 저장
  - 활성 함수 == 현재 호출 중인 함수, 스택 영역에 대기 중인 함수 포함
- **스택 영역에서 함수 호출~반환 과정**
  - 함수 호출 시 활성 레코드 생성되어 스택 영역 제일 위에 push
  - 함수 지역 변수는 활성화되어 있을 때의 함수 활성 레코드 내 메모리에 할당
    - 정적 변수 예외; 프로그램 로딩 시 데이터 영역에 할당
    - 지역 변수 초깃값 없는 경우 dummy 값으로 채워짐; 기본값 초기화 X, 로드타임 변수와 다른 점
  - 활성 레코드에는 함수 실행에 필요한 다른 정보도 저장
    - 함수 매개변수, 반환값, 호출된 위치의 명령어 메모리 주소 등
  - 스택 포인터 stack pointer는 항상 스택 영역의 제일 위 가리킴
  - 명령 포인터 instruction pointer 스택 영역 최상위에 위치한 활성 레코드 함수에 해당하는 코드 영역 가리킴
    - 프로그램이 현재 실행하고 있는 명령어를 가리키는 포인터
  - 함수 종료 시 반환값을 레지스터에 저장
  - 함수 종료되어 반환되면 활성화 기록은 스택에서 삭제
  - 함수를 호출할 때 메모리에 저장했던 레지스터 값, 명령 포인터 값들을 원래 위치로 복원
  - 명령 포인터는 함수 호출 전 위치 다시 가리키며, 거기서부터 호출한 함수 실행 재개
  - 함수 호출 지점은 호출된 함수의 반환값으로 치환

**힙 영역**

- 동적 메모리dynamic memory, 런타임 메모리run-time memory 할당
  - C의 `malloc / calloc / realloc`, C++의 `new / new[]` 등 사용해 요청
  - C에서는 힙에 할당된 메모리 초기화 X, C++에서는 new 연산자로 메모리 할당 시 생성자 사용해 초기화 가능
- 이름 붙일 수 없고, 메모리를 가리키는 포인터를 통해서만 접근 가능
  - 메모리 누수 memory leak; 메모리 주소 잃어버려 더 이상 접근할 수 없는 경우 발생
- 스택 영역과 같은 공간의 양 끝 차지, 점점 가까워지는 방향으로 증가

**인라인 확장inline expansion**

- 일부 컴파일러는 컴파일 중 함수 호출을 함수 전체 코드로 맞바꾸어 함수 호출 피하는 방식으로 성능 최적화
- 재귀 함수는 컴파일 시점에서 함수 호출이 얼마나 중첩될지 파악할 수 없어, 인라인 확장이 매우 어려움

> 로드타임 변수는 함수 반환값이나 지역 변수로 초기화 할 수 없음
>
> 함수 반환값, 지역 변수값은 런타임에 알 수 있기 때문
