# 만들면서 배우는 프로그레시브 웹 앱 (2017)

- 탈 아터, 2017
- 한민주, 양찬석 옮김, 2019
- [한빛미디어](https://www.hanbit.co.kr/realtime/books/book_view.html?p_code=E2915620212)

## 목차

- [chapter 1 프로그레시브 웹 앱 소개](./01.IntroToPWA.md)

  - 1.1 웹의 역습
  - 1.2 오늘날의 모바일 환경
  - 1.3 프로그레시브 웹 앱의 장점
  - 1.4 탭, 웹 그리고 서비스 워커

- [chapter 2 당신의 첫 번째 서비스 워커](./#)

  - 2.1 샘플 프로젝트 구성하기
  - 2.2 고담 임페리얼 호텔에 오신 것을 환영합니다
  - 2.3 코드 알아가기
  - 2.4 현재의 오프라인 사용자 경험
  - 2.5 첫 번째 서비스 워커 만들기
  - 2.6 점진적 향상이란?
  - 2.7 HTTPS와 서비스 워커
  - 2.8 웹에서 콘텐츠 가져오기
  - 2.9 오프라인 요청 감지하기
  - 2.10 HTML Response 생성하기
  - 2.11 서비스 워커의 범위(Scope) 이해하기
  - 2.12 정리

- [chapter 3 캐시 스토리지 API](./#)

  - 3.1 CacheStorage란 무엇인가
  - 3.2 언제 캐시할지 결정하기
  - 3.3 CacheStorage에 요청 저장하기
  - 3.4 CacheStorage로부터 요청 받아오기
  - 3.5 샘플 앱에서 캐싱하기
  - 3.6 각각의 요청에 올바른 응답 매칭하기
  - 3.7 HTTP 캐싱과 HTTP 헤더
  - 3.8 정리

- [chapter 4 서비스 워커 생명주기와 캐시 관리](./#)

  - 4.1 서비스 워커의 생명주기
  - 4.2 서비스 워커의 수명과 waitUntil의 중요성
  - 4.3 서비스 워커 업데이트하기
  - 4.4 캐시를 관리해야 하는 이유
  - 4.5 캐시 관리 및 이전 캐시 제거
  - 4.6 캐싱된 response를 다시 사용하기
  - 4.7 올바른 헤더 캐싱을 제공하기 위한 서버 설정
  - 4.8 개발자 도구
  - 4.9 정리

- [chapter 5 ‘오프라인 우선’을 받아들이기](./#)

  - 5.1 오프라인 우선이란 무엇입니까?
  - 5.2 일반적인 캐싱 패턴
  - 5.3 믹스 앤 매치, 새 패턴 생성하기
  - 5.4 캐싱 전략 세우기
  - 5.5 캐싱 전략 구현하기
  - 5.6 어플리케이션 쉘 아키텍처
  - 5.7 앱 셸 구현하기
  - 5.8 목표 달성
  - 5.9 정리

- [chapter 6 IndexedDB로 로컬에 데이터 저장하기](./#)

  - 6.1 IndexedDB란?
  - 6.2 IndexedDB 사용하기
  - 6.3 SQL Ninja를 위한 IndexedDB
  - 6.4 IndexedDB 실제로 적용하기
  - 6.5 프로미스를 활용한 데이터베이스
  - 6.6 IndexedDB 관리
  - 6.7 서비스 워커에서 IndexedDB 사용하기
  - 6.8 IndexedDB 에코시스템
  - 6.9 정리

- [chapter 7 백그라운드 동기화를 통한 오프라인 기능 보장](./#)

  - 7.1 백그라운드 동기화는 어떻게 작동하는가
  - 7.2 The SyncManager
  - 7.3 동기화 이벤트로 데이터 넘기기
  - 7.4 앱에 백그라운드 동기화 추가하기
  - 7.5 정리

- [chapter 8 메시지를 통한 서비스 워커와 페이지 간의 커뮤니케이션](./#)

  - 8.1 윈도우에서 서비스 워커로 메시지 보내기
  - 8.2 서비스 워커에서 열려있는 모든 윈도우로 메시지 보내기
  - 8.3 서비스 워커에서 특정 윈도우로 메시지 보내기
  - 8.4 MessageChannel로 커뮤니케이션 채널을 열어두기
  - 8.5 윈도우 간 통신하기
  - 8.6 동기화 이벤트에서 페이지로 메시지 보내기
  - 8.7 정리

- [chapter 9 인스톨 가능한 웹 앱으로 홈 화면 차지하기](./#)

  - 9.1 인스톨 가능한 웹 앱
  - 9.2 브라우저가 ‘앱 설치 배너’를 언제 표시할지 결정하는 방법
  - 9.3 웹 앱 매니페스트의 구조
  - 9.4 다양한 플랫폼 호환성 고려하기
  - 9.5 정리

- [chapter 10 사용자에게 푸시 알림 보내기](./#)

  - 10.1 푸시 알림의 생애
  - 10.2 알림 생성하기
  - 10.3 푸시 이벤트 구독하기
  - 10.4 서버에서 푸시 이벤트 전송하기
  - 10.5 푸시 이벤트 수신하고 알림 표시하기
  - 10.6 정리

- [chapter 11 프로그레시브 웹 앱 UX](./#)

  - 11.1 우아함과 신뢰
  - 11.2 서비스 워커에서 상태정보 알려주기
  - 11.3 프로그레시브 UI KITT로 커뮤니케이션하기
  - 11.4 프로그레시브 웹 앱의 일반적인 메시지
  - 11.5 올바른 단어 선택
  - 11.6 사용자에게 명확히 설명하기
  - 11.7 프로그레시브 웹 앱 디자인
  - 11.8 설치 프롬프트 책임지기
  - 11.9 RAIL로 성능 측정 및 성능 목표 설정하기
  - 11.10 정리

- [chapter 12 PWA의 미래](./#)

  - 12.1 Payment Request API로 결제 수락하기
  - 12.2 Credential Management API로 사용자 관리하기
  - 12.3 WebGL을 사용한 Real-Time Graphics
  - 12.4 음성 인식 지원을 위한 첨단 API
  - 12.5 WebVR을 통한 브라우저 내 가상 현실
  - 12.6 앱에서 앱으로 쉽게 공유하기
  - 12.7 매끄러운 미디어 재생 UI
  - 12.8 다가올 위대한 시대

- [부록](./#)
  - A 서비스 워커 : ES2015 적용하기
  - B 전면 광고를 싫어하는 이유
  - C CORS vs NO-CORS
