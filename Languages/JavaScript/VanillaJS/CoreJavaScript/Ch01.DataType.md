# Ch01. 데이터 타입

## 데이터 타입의 종류

| 기본형(원시형, primitive type) |                  참조형(reference type)                   |
| :----------------------------: | :-------------------------------------------------------: |
|     값이 담긴 주솟값 복제      | 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값 복제 |
|             불변성             |                                                           |
|             number             |                          Object                           |
|             string             |                           Array                           |
|            boolean             |                         Function                          |
|             `null`             |                           Date                            |
|          `undefined`           |                          RegExp                           |
|            `Symbol`            |                       Map, WeakMap                        |
|                                |                       Set, WeakSet                        |

## 데이터 타입에 관한 배경지식

### 메모리-데이터

각 비트는 고유한 식별자(=> 메모리 주솟값)를 가짐

바이트 : 비트들을 한 단위로 묶어 검색 시간 줄이고, 한번에 표현할 수 있는 데이터를 늘림

### 식별자-변수

- 변수 : 변경 가능한 데이터가 담길 수 있는 공간
- 식별자 : 변수명, 변수를 식별하는데 사용하는 이름

## 변수 선언과 데이터 할당

변수 영역과 데이터 영역을 다르게 할당해, 변경되는 데이터 처리 비용을 줄이고 중복 데이터에 대한 효율을 높임

- 변수 선언 : 메모리에서 비어있는 공간 하나를 확보, 해당 메모리 주소를 접근하기 위해 식별자/변수명을 지정
- 데이터 할당 : 데이터 저장을 위한 별도의 메모리 공간 확보하고 그곳에 데이터 저장, 데이터가 저장된 메모리 주소를 변수 선언된 메모리 영역에 저장
- 변수의 데이터가 변경된 경우, 기존 데이터 그대로 두고 변경된 데이터를 새로운 메모리에 저장해 변수 영역과 연결
  - 기존 데이터는 자신의 주소를 저장하는 변수가 하나도 없는 경우(참조 카운트가 0이 되는 경우), 가비지 컬렉터에 의해 수거됨
  - 참조 카운트: 어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수

## 기본형 데이터와 참조형 데이터

### 불변값

- 변수와 상수 구분: **_변수 영역 메모리_**에 다른 데이터를 재할당할 수 있는가 여부
- 불변성 여부 구분: 한번 만들어진 데이터 값을 바꿀 수 있는지 여부, **_데이터 메모리_**와 연관, 기본형 데이터는 모두 불변값
  - 예를 들어 숫자 5를 변수 a와 b에 저장하는 경우 a와 b 모두 숫자 5에 대한 동일한 데이터 메모리 주소값을 저장하게 됨
  - b의 값을 7로 변경하는 경우, 기존 메모리 영역에서 7 값이 저장된 곳이 있으면 그 주솟값을 참조하는 것으로 변경하고, 저장된 값이 없으면 새로 만들어서 저장, 가비지 컬렉터에 의해 수거되기 전까지 남아있음

### 가변값

참조형 데이터의 ‘가변’은 데이터 자체가 아닌 내부 프로퍼티를 변경할 때 성립하는 것

참조형 데이터는 가변값인 경우가 많지만 경우에 따라 변경 불가하거나 불변값으로 활용할 수 있음

일반적으로 참조형 데이터를 변수에 할당하는 경우

1. 참조형 데이터의 변수명 저장
2. **내부 프로퍼티들을 참조하기 위한 메모리 할당**
3. 내부 프로퍼티들의 변수명(Object key) 저장
4. 내부 프로퍼티들의 데이터 저장
5. 내부 프로퍼티의 데이터가 변경되는 경우, 새로운 데이터 값을 찾거나 저장하고, 해당 메모리 주소를 업데이트

참조형 데이터를 단순히 대입 연산(`=`) 사용해 복사하는 경우, 내부 프로퍼티 참조하는 주소값만 복사되는 것

> JS는 기본형 데이터도 결국 주솟값을 참조한다는 것은 동일하다
> 참조형 데이터는 내부 프로퍼티명을 저장하는 과정이 하나 더 추가되는 차이만 있음

## 불변 객체

### 불변 객체를 만드는 간단한 방법

불변 객체가 필요한 상황

- 값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우

#### 얕은 복사를 만드는 간단한 방법

- target 객체의 프로퍼티들을 새로운 객체 프로퍼티로 일일이 복사
- `getter/setter` 는 복사되지 않음

```javascript
for (let prop in target) {
  result[prop] = target[prop];
}
```

#### 깊은 복사를 만드는 간단한 방법

- 재귀 활용

```javascript
const deepCopy = (target) => {
  ...
  if (typeof target === 'object' && target !== null){
    for (let prop in target) {
      result[prop] = deepCopy(target[prop]);
    }
	} else {
    result = target;
  }
  ...
}
```

- `hasOwnProperty` 메서드 활용
  - prototype chaining을 통해 상속된 프로퍼티를 복사하지 않도록 할 수 있음
- `Object.getOwnPropertyDescriptor` / `Object.getOwnPropertyDescriptors` : `getter/setter` 복사하는 경우

- JSON 메서드 활용

  `JSON.parse(JSON.stringify(target))`

  - 메서드, `__proto__`, `getter/setter` 등 JSON으로 변경할 수 없는 프로퍼티는 무시
  - 순수한 정보만 다룰 때 활용하기 좋음

## `undefined`, `null`

### JS엔진이 자동으로 `undefined`를 부여하는 경우

- 값을 대입하지 않은 변수; 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근
- 객체 내부에 존재하지 않는 프로퍼티에 접근
- `return` 없거나 호출되지 않는 함수 실행

비어있는 요소와 undefined가 할당된 요소는 다름

- 비어있는 요소는 `forEach`, `map`, `filter`, `reduce` 등 배열 메서드의 순회 대상에서 제외됨
- 데이터 영역 메모리 주소 참조가 없기 때문

```javascript
const a = [];
a.length = 3;
console.log(a); // [empty X 3]

const b = [undefined, undefined, undefined];
console.log(b); // [undefined, undefined, undefined]
```

사용자가 명시적으로 부여한 경우와 비어있는 요소에 접근할 때 반환되는 경우의 차이

- 사용자가 명시적으로 부여한 경우: `undefined`라는 실존하는 값을 반환
- 비어있는 요소에 접근하는 경우: 문자 그대로 값이 없다는 것, **_변수 선언시 자동으로 `undefined`를 할당하는 것이 아님!!_**

비어있는 것을 명시적으로 나타낼 때는 `undefined` 보다 `null` 을 사용하는 것이 좋다

- 원래 이런 용도로 만들어진 데이터 타입
- `typeof null === object` ; JS 자체 버그
- null 판단을 위해서는 동등 연산자(`==`) 가 아닌 일치 연산자(`===`) 를 써야 함

---

###### tags: `Book Note`, `코어 자바스크립트`, `JavaScript`
