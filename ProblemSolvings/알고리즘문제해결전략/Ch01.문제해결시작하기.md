# 01. 문제 해결과 프로그래밍 대회

### 입문자를 위한 추천 커리큘럼

1. Ch02. 문제 해결 전략
2. Ch03. 코딩과 디버깅
3. Ch04. 알고리즘 시간 복잡도 분석
4. Ch06. 무식하게 풀기
5. Ch07. 분할 정복
6. Ch08. 동적 계획법
7. Ch18. 선형 자료 구조
8. Ch19. 큐, 스텍, 덱
9. Ch21. 트리 구현과 순회
10. Ch22. 이진 검색 트리
11. Ch23. 우선순위 큐와 힙
12. Ch27. 그래프의 표현과 정의
13. Ch28. 그래프의 깊이 우선 탐색
14. Ch29. 그래프의 너비 우선 탐색
15. Ch30. 최단 경로 알고리즘

> 복잡한 알고리즘을 하나 더 아는 것보다 실제 자신이 아는 것을 이용해 문제를 풀 수 있는 능력이 훨씬 더 중요하다. 
> 가장 중요한 주제들을 먼저 공부한 뒤에는 가능한 한 많은 문제를 풀어 보며 경험을 쌓는 것이 좋다.

<br />

---

# 02. 문제 해결 개관

## 문제 해결 과정

<어떻게 문제를 풀 것인가(How to Solve it)>; 문제 해결 연구의 고전

1. 문제를 이해한다
2. 어떻게 풀지 계획을 세운다
3. 계획을 수행해서 문제를 해결한다
4. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다

⇒ 프로그래밍 대회에 적용

1. 문제를 읽고 이해한다
2. 문제를 익숙한 용어로 재정의한다
3. 어떻게 해결할지 계획을 세운다
4. 계획을 검증한다
5. 프로그램으로 구현한다
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다

**1. 문제를 읽고 이해하기**

문제를 잘못 읽는 실수

- 모든 참가자들이 공통적으로 하는 실수
- 사소한 제약 조건을 잘못 이해하면 풀 수 없게 되는 문제들이 흔하다

**2. 재정의와 추상화**

재정의

- 문제를 자신의 언어로 풀어 쓰는 것

추상화

- 복잡한 개념을 수학적/전산학적 개념으로 옮겨 표현
- 프로그래밍이 나아갈 방향을 결정
- 문제의 본질을 어떤 방식으로 재구성하느냐에 따라 어려운 문제를 쉽게 만들수도, 쉬운 문제를 어렵게 만들수도

**3. 계획 세우기**

문제를 어떤 방식으로 해결할지 결정하고, 사용할 알고리즘와 자료구조 선택

- 문제 해결에서 가장 중요한 단계

**4. 계획 검증하기**

모든 경우에 요구 조건을 정확히 수행하는 지 증명하고,

수행에 걸리는 시간과 메모리가 문제 제한 내에 들어가는지 확인

**5. 계획 수행하기**

계획을 프로그래밍 구현으로

**6. 회고**

장기적으로 가장 큰 영향을 미치는 단계

문제를 한 번만 풀어서는 그 문제에서 배울 수 있는 것들을 다 배우지 못하는 경우가 많다

더 효율적인 알고리즘, 간결한 코드, 더 직관적인 방법을 찾기 위해

가장 좋은 방법은 문제를 풀 때마다 코드와 함께 자신의 경험을 기록으로 남기는 것

- 간단한 해법
- 접근 방식
- 해법을 찾는 데 결정적이었던 깨달음
- 오답 원인
- 다른 사람의 코드

문제를 풀지 못한 경우

- 일정 시간이 지나도록 고민해도 답을 찾지 못한 경우 다른 사람의 코드/풀이 참조
- 이 경우 반드시 복기; 왜 풀이를 떠올리지 못했는지

## 문제 해결 전략

직관적 아이디어에 체계적으로 접근하기 위한 질문들

1. 비슷한 문제를 풀어본 적이 있던가? 
    - 기존에 접했던 문제가 온전한 경험이 되려면 그 원리를 완전히 이해하고 변형할 수 있어야
2. 단순한 방법에서 시작할 수 있을까? 
    - brute-force → 좀더 효율적인 자료구조/알고리즘, 최적화
3. 내가 문제 푸는 과정을 수식화할 수 있을까? 
    - 영감이 필요한 문제를 만났을 때 손으로 여러 간단한 입력을 해결해 보는 것
4. 문제를 단순화할 수 없을까?
    - 문제의 제약 조건을 없애보거나 변수의 수를 줄이거나 다차원 문제를 1차원으로 줄여 표현해보는 것
5. 그림으로 그려볼 수 있을까?
6. 수식으로 표현할 수 있을까?
7. 문제를 분해할 수 있을까?
    - 다루기 좀더 쉬운 형태로 문제 변형하는 접근
    - 제약 조건을 분해; 한 개의 복잡한 조건 ⇒ 여러 개의 단순한 조건
8. 뒤에서부터 생각해서 문제를 풀 수 있을까?
9. 순서를 강제할 수 있을까?
    - 순서 없는 문제에 순서를 강제
    - 경우의 수 셀 때 유용
10. 특정 형태의 답만을 고려할 수 있을까?
    - 정규화canonicalization

---
# 03. 코딩과 디버깅에 관하여

## 좋은 코드를 짜기 위한 원칙

### 간결한 코드 작성

- 반복문 등 자주 쓰면서 실수하기 쉬운 코드를 단순화해서 재사용

### 적극적으로 코드 재사용하기

- 모듈화

- 실무 코드처럼은 못하더라도 가독성 높이려는 노력

### 표준 라이브러리 공부하기

- 기초 알고리즘을 직접 작성하기 보다는 표준 라이브러리 최대한 활용

### 항상 같은 형태로 프로그램 작성하기

- 자주 사용하는 알고리즘, 함수 등 

- 한번 검증된 코드를 작성하고 이것만 꾸준히 사용해야 디버깅 시간을 아낌

### 일관적이고 명료한 명명법 사용하기

- 모호하지 않은 변수명, 함수명 사용, 네이밍 컨벤션 준수 등 

- 가독성을 높여 디버깅 시간을 아낌

### 모든 자료를 정규화해서 저장하기

- 같은 자료(날짜, 각도, 분수 등)는 한 가지 형태로 저장

- 자료를 입력받거나 계산하자마자 곧장 이루어져야

### 코드와 데이터를 분리하기

## 자주 하는 실수

### 산술 overflow

### 배열 범위 밖 원소에 접근

- 0으로 시작하는 범위, 1로 시작하는 범위 혼동 등

### 일관되지 않은 범위 표현 방식 사용

- 배열 범위를 나타내는 열린 구간, 닫힌 구간, 반 열린 구간(대다수 프로그래밍 언어가 사용)

### off-by-one 오류

- 계산의 큰 줄기는 맞지만 하나가 모자라거나 많아서 틀리는 코드 오류

- 반복문에서 < - ≤, > - ≥ 연산자 혼동, 반 열린 구간 - 닫힌 구간 혼동 등

- 최소 입력이 주어졌을 때 코드가 어떻게 동작할지 되새겨 보면서 프로그래밍해야

### 컴파일러가 잡아주지 못하는 상수 오타

### Stack Overflow

- call stack overflow

- 재귀 호출 깊이가 너무 깊어지는 경우가 많음

- 언어에 따라 스택 메모리 대신 힙 메모리에 할당하도록

### 다차원 배열 인덱스 순서 바꿔 쓰기

- 특히 동적 계획법 메모이제이션에서 특정 배열에 접근하는 위치 헷갈리는 경우; 접근 방식을 하나로 통일해야

### 잘못된 비교 함수 작성

- 언어에 따라 비교 연산 방식이 조금씩 다름

### 최소, 최대 예외 잘못 다루기

### 연산자 우선순위 잘못 쓰기

### 너무 느린 입출력 방식 선택

### 변수 초기화 문제

## 디버깅

- 대부분 코드가 길지 않기 때문에, 눈으로 디버깅하는 것이 빠름

- 눈으로 디버깅하기 어렵다면, 코드가 클린하지 않다는 것

빠른 디버깅 팁

- 작은 입력에 대해 제대로 실행되는지 확인
- assertion 활용; 주어진 조건이 거짓일 때 `throw Error`, 좀더 빠르게 검증
- 프로그램의 계산 중간 결과 출력

## 테스트

### 스캐폴딩 scaffolding

임의의 작은 입력을 자동으로 생성해 프로그램을 돌려 보고, 그 답안을 검증하는 프로그램

- ex. 배열 정렬 코드 검증 ⇒ 임의의 배열 무한 생성, 구현한 코드의 결과값 - 내장 함수 결과값 비교

## 산술 overflow

- 컴퓨터의 모든 변수에는 담을 수 있는 크기가 제한됨

자주 발생하는 문제

- 계산의 중간값이 overflow 되는 문제
- 무한대에 해당하는 값끼리 계산되는 문제
- 프로모션; 피연산자의 자료형이 다르거나 범위가 너무 작은 경우 컴파일러가 같은 자료형으로 변환, 특히 부호 있는 수와 없는 수가 섞일 때 버그 발생

문제를 방지하는 방법

- 큰 자료형 사용
- 연산의 순서를 조정

## 실수(`float`/`double`) 문제

컴퓨터의 모든 실수 변수는 정확도가 제한된 근사값 저장

### IEEE 754 표준

- **이진수로 실수 표기**
- **부동 소수점 표기**
    - 어떤 형태의 숫자건 소수점을 적절히 옮겨서,
    - 소수점 위에 한 자리만 남기고,
    - 최상위 비트에서부터 표현할 수 있는만큼 표시하고 나머지는 반올림 처리
    - 맨 앞의 1은 생략
        - ex. 11.625(10) ⇒ 1011.101(2) ⇒ 1.011101 ⇒ .01101 ⇒ 01101 로 저장
    - 지수부 보다 가수부에 훨씬 많은 비트 부여하여 정확도를 높임
        - ex. 64비트 실수형 : 부호 1 + 지수 11 + 가수 52 ⇒ $-2^{10}+2 \leadsto 2^{10}-1$

    ```javascript
    1/10*3 === 3/10 // false
    1/10*3 // 0.30000000000000004
    3/10   // 0.3
    ```

    - 실수 비교 시 오차 범위를 정해야 함; 64비트에서 `1e-10` 정도
    - 입력 데이터 범위를 예상하기 어려운 경우 상대 오차 사용
        - $relativeError(a, b) = \frac{|a-b|}  {max(|a|, |b|)}$

        ```javascript
        const relativeEqual = (a, b) => {
        	const diff = Math.abs(a-b);
        	return (diff < 1e-10) 
        		// 절대 오차 범위 이내 인 경우
        		? true
        		// 절대 오차 범위 밖인 경우 상대 오차 범위 비교한 결과값
        		: diff <= 1e-8 * Math.max(Math.abs(a), Math.abs(b));
        };
        ```

- **무한대, 비정규수(subnormal number), NaN 등 특수한 값 존재**

### 코드의 수치적 안정성

어떤 프로그램 실행 과정에서 발생하는 오차가 더 커지지 않는 것

> 가장 좋은 방법은 실수 연산을 하지 않는 것

의외로 많은 문제들은 적절한 변형을 가해 실수 연산을 없앨 수 있다